import{_ as a,c as i,o as t,a as n}from"./app.BLq0Lh-m.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notion/data为什么是函数问题.md","filePath":"notion/data为什么是函数问题.md","lastUpdated":1756031832000}'),e={name:"notion/data为什么是函数问题.md"};function p(l,s,d,r,h,o){return t(),i("div",null,s[0]||(s[0]=[n(`<p>首先我们需要了解data两种不同的类型有什么区别：</p><ul><li>当我们组件中的data写成一个<strong>函数</strong>时，数据是以函数返回值形式定义的，这样每复用一次data，都会返回一份新的data，拥有<strong>自己的作用域</strong>，不会产生数据污染。</li><li>当我们组件中的data写成一个<strong>对象</strong>时，对象是引用数据类型，它就会共用一个内存地址，在多次使用该组件时，改变其中一个组件的值会影响全部使用该组件的值。</li></ul><p>2.理解组件中的 data 必须是一个函数：</p><ul><li>在vue中一个组件可能会被其他的组件引用，为了防止多个组件实例对象之间共用一个data，产生数据污染。将data定义成一个函数，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响initData时会将其作为工厂函数都会返回全新data对象。</li></ul><p>如果data是对象；初始化组件时</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.data;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>this.options相当于被赋值了data对象的指针；指向堆中的对象；</p><p>如果是函数：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>函数每次执行时，都会创建新的作用域，返回新的对象，所以组件被多次调用时，相互之间不会影响</p>`,10)]))}const g=a(e,[["render",p]]);export{c as __pageData,g as default};
