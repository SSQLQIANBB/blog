import{_ as i,c as a,o as e,a as l}from"./app.DqW9zJQX.js";const n="/blog/assets/f0e30070fe431c9c9785ff4e9d91b4bd.LpODhNZ5.png",t="/blog/assets/359a370e0d302d0f316b2753fb4e178a.CGxF74_N.png",r="/blog/assets/fa9874892d6f5b7f6181f2641711216f.DvKUEccv.png",p="/blog/assets/0001b1e669fee8f11eea55884ecfb5fc.Bhu4paZu.png",h="/blog/assets/31ca27a1ac11600f9f5e829f4caf09e9.XtHn8VLU.awebp",o="/blog/assets/ce202728005b77c74d798b6f7f0d1d6a.CTXDt7l0.awebp",d="/blog/assets/57c7f256edb68884f48a628be949bec0.1IBntYC_.png",k="/blog/assets/05dfd82adcaa7ab4461fafe06af1d66e.D91Riam4.png",c="/blog/assets/000fb2e4df01ea324b9e84a669d0f541.CWIfjz-x.png",g="/blog/assets/097d43f0d5fba0f9d6ac80ac0902c024.C5ELuf6f.png",E="/blog/assets/0391194bf88f060b5910950a8127abdb.BFtmUGkk.webp",u="/blog/assets/0d939042a049978a92fa97e3c0d33e31.DH3OhM3i.png",b="/blog/assets/299da2da27b1f103f2d3af54560ce8ca.DUtoI5Ig.png",y="/blog/assets/73da8d30ebb392e5362de332603aaa87.Cn-FKyzv.png",m="/blog/assets/0d655b84c0f608af51137fa3b021cfb3.BzKMUWpw.png",_=JSON.parse('{"title":"Resource Scheduling（资源调度）优化记录笔记","description":"","frontmatter":{},"headers":[],"relativePath":"notion/web性能.md","filePath":"notion/web性能.md","lastUpdated":1770269353000}'),f={name:"notion/web性能.md"};function F(C,s,B,q,v,D){return e(),a("div",null,s[0]||(s[0]=[l('<p><img src="'+n+'" alt="image.png" loading="lazy"></p><blockquote><p>web性能是对网站或应用程序的客观度量和用户的体验，有以下主要方面</p></blockquote><p><img src="'+t+'" alt="zp4wrjatnb.png" loading="lazy"></p><ol><li>减少总体负载时间</li><li>尽快使网站可用： 网站从开始加载，到达到可用状态为止所需的时间被称为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive" target="_blank" rel="noopener noreferrer">交互等待时间</a></li><li>流畅性和交互性</li><li>感知性能</li><li>性能测量</li><li>找出未使用的js和css</li></ol><h2 id="覆盖率-找出未使用的-javascript-和-css" tabindex="-1">覆盖率：找出未使用的 JavaScript 和 CSS <a class="header-anchor" href="#覆盖率-找出未使用的-javascript-和-css" aria-label="Permalink to &quot;覆盖率：找出未使用的 JavaScript 和 CSS&quot;">​</a></h2><p>Chrome 开发者工具中的 <strong>Coverage</strong> 面板可以帮助您找到未使用的 JavaScript 和 CSS 代码。移除未使用的代码可以加快网页加载速度，并节省用户的移动数据流量。</p><p><img src="'+r+'" alt="analyzing-code-coverage.png" loading="lazy"></p><h2 id="记录代码覆盖率" tabindex="-1">记录代码覆盖率 <a class="header-anchor" href="#记录代码覆盖率" aria-label="Permalink to &quot;记录代码覆盖率&quot;">​</a></h2><p>若要捕获代码覆盖率，请执行以下操作：</p><ol><li>如需设置覆盖率范围，请在<strong>覆盖率</strong>面板顶部的操作栏中，从下拉列表中选择<strong>按函数</strong>或<strong>按块</strong>。</li><li>如需开始录制，请点击刷新 <strong>Start instrumenting 覆盖率并重新加载页面</strong> <strong>Coverage</strong> 面板会重新加载页面、捕获加载页面所需的代码，并在您与页面互动时继续录制。</li><li>如需停止记录代码覆盖率，请点击 stop_circle <strong>停止检测覆盖率并显示结果</strong>。</li></ol><h2 id="分析代码覆盖率" tabindex="-1">分析代码覆盖率 <a class="header-anchor" href="#分析代码覆盖率" aria-label="Permalink to &quot;分析代码覆盖率&quot;">​</a></h2><p><strong>覆盖率</strong>面板中的表格显示了分析了哪些资源以及每项资源使用了多少代码。</p><p>点击某一行即可在<strong>来源</strong>面板中打开该资源，并查看已使用代码和未使用的代码逐行细分。所有未使用的代码行都会用红线标记，列旁边会显示行号。</p><p><img src="'+p+'" alt="code-coverage-report.png" loading="lazy"></p><ul><li><strong>网址</strong>列是所分析资源的网址。</li><li><strong>Type</strong> 列显示资源是包含 CSS 和/或 JavaScript。</li><li><strong>Total Bytes</strong> 列是资源的总大小（以字节为单位）。</li><li><strong>Unused Bytes</strong> 列是未使用的字节数。</li><li>最后一个未命名的列是直观显示 <strong>Total Bytes</strong> 和 <strong>Unused Bytes</strong> 列。竖条的红色部分是未使用的字节。灰色部分使用字节。</li></ul><h2 id="如何消除阻塞渲染的脚本" tabindex="-1">如何消除阻塞渲染的脚本 <a class="header-anchor" href="#如何消除阻塞渲染的脚本" aria-label="Permalink to &quot;如何消除阻塞渲染的脚本&quot;">​</a></h2><p>确定关键代码后，请将该代码从阻止呈现的网址移到 HTML 网页中的内嵌 <code>script</code> 标记。网页加载时，该网页将具备处理网页核心功能所需的数据。</p><p>如果阻止呈现的网址中包含不重要的代码，您可以将其保留在网址中，然后使用 <code>async</code> 或 <code>defer</code> 属性标记该网址（另请参阅<a href="https://web.dev/articles/critical-rendering-path/adding-interactivity-with-javascript?hl=zh-cn" target="_blank" rel="noopener noreferrer">使用 JavaScript 添加互动</a>）。</p><p>应移除完全未使用的代码（请参阅<a href="https://web.dev/articles/remove-unused-code?hl=zh-cn" target="_blank" rel="noopener noreferrer">移除未使用的代码</a>）。</p><h2 id="如何消除阻塞渲染的样式表" tabindex="-1">如何消除阻塞渲染的样式表 <a class="header-anchor" href="#如何消除阻塞渲染的样式表" aria-label="Permalink to &quot;如何消除阻塞渲染的样式表&quot;">​</a></h2><p>与 <code>&lt;script&gt;</code> 标记中的内嵌代码类似，在 HTML 页面 <code>head</code> 的 <code>&lt;style&gt;</code> 代码块内，首次绘制所需的内嵌关键样式。然后，使用 <code>preload</code> 链接异步加载其余样式（请参阅<a href="https://web.dev/articles/defer-non-critical-css?hl=zh-cn" target="_blank" rel="noopener noreferrer">推迟未使用的 CSS</a>）。</p><p>请考虑使用<a href="https://github.com/addyosmani/critical/blob/master/README.md" target="_blank" rel="noopener noreferrer">关键工具</a>自动执行提取和内嵌“首屏”CSS 的过程。</p><p>另一种消除阻塞渲染的样式的方法是将这些样式拆分成不同的文件，按媒体查询进行整理。然后为每个样式表链接添加媒体属性。 加载网页时，浏览器只会阻止首次绘制以检索与用户的设备匹配的样式表（请参阅<a href="https://web.dev/articles/critical-rendering-path/render-blocking-css?hl=zh-cn" target="_blank" rel="noopener noreferrer">阻塞渲染的 CSS</a>）。</p><p>最后，您需要缩减 CSS 的大小，以移除所有多余的空格或字符（请参阅<a href="https://web.dev/articles/minify-css?hl=zh-cn" target="_blank" rel="noopener noreferrer">缩减 CSS 大小</a>）。 这可确保向用户发送最小的 bundle。</p><h2 id="阻塞渲染的css" tabindex="-1">阻塞渲染的Css <a class="header-anchor" href="#阻塞渲染的css" aria-label="Permalink to &quot;阻塞渲染的Css&quot;">​</a></h2><ul><li>默认情况下，CSS 被视为阻塞渲染的资源。</li><li>通过媒体类型和媒体查询，我们可以将一些 CSS 资源标记为不阻塞渲染。</li><li>浏览器会下载所有 CSS 资源（无论阻塞行为还是非阻塞行为）。</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> media</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;portrait.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> media</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orientation:portrait&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;print.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> media</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;print&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>第一个声明是阻塞渲染，在所有条件中都匹配。</li><li>第二个声明也是阻塞渲染：“all”是默认类型，因此，如果您不指定任何类型，系统会将其隐式设置为“all”。因此，第一个声明和第二个声明实际上是等效的。</li><li>第三个声明具有动态媒体查询，系统会在网页加载时计算该查询。根据网页加载时设备的屏幕方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。</li><li>最后一个声明仅在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。</li></ul><h2 id="脚本执行以及async和defer" tabindex="-1">脚本执行以及async和defer <a class="header-anchor" href="#脚本执行以及async和defer" aria-label="Permalink to &quot;脚本执行以及async和defer&quot;">​</a></h2><blockquote><p>script本就是一个宏任务，因此执行时会阻塞js引擎，但是js引擎又是和GUI渲染引擎相斥的，所以会阻塞html解析，当下载完js脚本，会依次执行宏任务中的代码，执行完成之后，进入下一个宏任务，也就是下载下一个script中的脚本文件，依次执行</p></blockquote><p>async 和 defer</p><h3 id="head-标签中的-script-使用-async" tabindex="-1"><code>head</code> 标签中的 <code>script</code> 使用 async <a class="header-anchor" href="#head-标签中的-script-使用-async" aria-label="Permalink to &quot;`head` 标签中的 `script` 使用 async&quot;">​</a></h3><p>下面是一个页面使用 <code>async</code> 加载脚本，并将其放在 head 标签中：</p><p><img src="'+h+'" alt="image" loading="lazy"></p><p>脚本以异步的方式获取，获取脚本后，HTML 解析会暂停转而去执行 script 脚本，脚本执行完成后才会恢复 HTML 的解析。</p><h3 id="head-标签中的-script-使用-defer" tabindex="-1"><code>head</code> 标签中的 <code>script</code> 使用 defer <a class="header-anchor" href="#head-标签中的-script-使用-defer" aria-label="Permalink to &quot;`head` 标签中的 `script` 使用 defer&quot;">​</a></h3><p>下面是一个页面使用 <code>defer</code> 加载脚本，并将其放在 head 标签中：</p><p><img src="'+o+`" alt="image" loading="lazy"></p><p>脚本是异步获取的，只有在 HTML 解析完成后才会执行。</p><p>作者：夏影_July链接：<a href="https://juejin.cn/post/7333937659838627892%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7333937659838627892来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><h2 id="preload和prefetch" tabindex="-1">preload和prefetch <a class="header-anchor" href="#preload和prefetch" aria-label="Permalink to &quot;preload和prefetch&quot;">​</a></h2><p><strong>注：preload只能在head中使用，参考body-ok规范</strong></p><p><strong>preload 提前加载</strong></p><blockquote><p>Preload主要是让浏览器提前加载资源（加载后并不会立即执行），然后会在需要执行的时候执行。并且 onload 事件必须等页面所有资源都加载完成才触发，而当给某个资源加上 preload 后，该资源将不会阻塞 onload。</p></blockquote><p><strong>prefetch 预判加载</strong></p><blockquote><p>preload 用于提前加载用于当前页面的资源，而 prefetch 则是用于加载未来（比如下一个页面）会用到的资源，并且告诉浏览器在空闲的时候去下载，它会将下载资源的优先级降到最低。</p></blockquote><p>使用值为 <code>preload</code> 的 <code>rel</code> 属性，这会将 <code>&lt;link&gt;</code> 标签转变成任何我们想要的资源的预加载器。你还需要指定：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#href" target="_blank" rel="noopener noreferrer"><code>href</code></a> 属性中的资源路径。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#as" target="_blank" rel="noopener noreferrer"><code>as</code></a> 属性中的资源类型。</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;utf-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;JS and CSS preload example&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;bouncing balls&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在预加载启用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">CORS</a> 的资源（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch" target="_blank" rel="noopener noreferrer"><code>fetch()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer"><code>XMLHttpRequest</code></a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face" target="_blank" rel="noopener noreferrer">字体</a>）时，需要特别注意在你的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link" target="_blank" rel="noopener noreferrer"><code>&lt;link&gt;</code></a> 元素上设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#crossorigin" target="_blank" rel="noopener noreferrer"><code>crossorigin</code></a> 属性。该属性需要设置为与资源的 CORS 和凭据模式相匹配，即使获取请求不跨域也需要设置。</p><p>优点：</p><ul><li><p>预加载我们的 CSS 和 JavaScript 文件，以便它们在稍后渲染页面时立即可用</p></li><li><p>可以使用脚本来执行它们</p><p><em>例如，这里我们创建一个</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLLinkElement" target="_blank" rel="noopener noreferrer"><em><code>HTMLLinkElement</code></em></a> <em>实例，然后将其附加到 DOM 中：</em></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> preloadLink</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;link&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">preloadLink.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myscript.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">preloadLink.rel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;preload&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">preloadLink.as </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(preloadLink);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><em>这意味着浏览器将预加载</em> <em><code>myscript.js</code></em> <em>文件，但实际上还没有使用它。要使用它，你可以这样做：</em></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> preloadedScript</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">preloadedScript.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myscript.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(preloadedScript);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当你想要预加载一个脚本，但需要将执行推迟到确切需要它的时候，这很有用</p></li></ul><h3 id="什么类型的内容可以被预加载" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel/preload#%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%9F" target="_blank" rel="noopener noreferrer">什么类型的内容可以被预加载？</a> <a class="header-anchor" href="#什么类型的内容可以被预加载" aria-label="Permalink to &quot;[什么类型的内容可以被预加载？](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel/preload#%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%9F)&quot;">​</a></h3><p>可以预加载多种类型的内容。<code>as</code> 属性可能的值包括：</p><ul><li><code>audio</code>：音频文件，通常在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="noopener noreferrer"><code>&lt;audio&gt;</code></a> 中使用。</li><li><code>document</code>：用于嵌入在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/frame" target="_blank" rel="noopener noreferrer"><code>&lt;frame&gt;</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener noreferrer"><code>&lt;iframe&gt;</code></a> 中的 HTML 文档。</li><li><code>embed</code>：用于嵌入在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" target="_blank" rel="noopener noreferrer"><code>&lt;embed&gt;</code></a> 元素中的资源。</li><li><code>fetch</code>：通过 fetch 或 XHR 请求访问的资源，例如 ArrayBuffer、WebAssembly 二进制文件或 JSON 文件。</li><li><code>font</code>：字体文件。</li><li><code>image</code>：图像文件。</li><li><code>object</code>：要嵌入在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object" target="_blank" rel="noopener noreferrer"><code>&lt;object&gt;</code></a> 元素中的资源。</li><li><code>script</code>：JavaScript 文件。</li><li><code>style</code>：CSS 样式表。</li><li><code>track</code>：WebVTT 文件。</li><li><code>worker</code>：JavaScript web worker 或 shared worker。</li><li><code>video</code>：视频文件，通常在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener noreferrer"><code>&lt;video&gt;</code></a> 中使用。</li></ul><h2 id="其他资源预加载机制" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel/preload#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">其他资源预加载机制</a> <a class="header-anchor" href="#其他资源预加载机制" aria-label="Permalink to &quot;[其他资源预加载机制](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel/preload#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)&quot;">​</a></h2><p>还存在其他预加载特性，但都不如 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 适合该目的：</p><ul><li><p><code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 在浏览器中支持已久，但它是用于预取将在下一次导航/页面加载时使用的资源（例如，当你跳转到下一页时）。这是可以的，但对于当前页面没有用！此外，浏览器会给预取（<code>prefetch</code>）的资源比预加载（<code>preload</code>）的资源更低的优先级——当前页面比下一页更重要。有关更多详细信息，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Prefetch" target="_blank" rel="noopener noreferrer">预取</a>。</p></li><li><p><code>&lt;link rel=&quot;prerender&quot;&gt;</code> 在后台渲染指定的网页，如果用户导航到该页面，可以加速其加载。由于有可能浪费用户的带宽，Chrome 将 <code>prerender</code> 视为 <a href="https://developer.chrome.com/blog/nostate-prefetch/" target="_blank" rel="noopener noreferrer">NoState 预取</a>。</p></li><li><p><code>&lt;link rel=&quot;subresource&quot;&gt;</code>  一段时间以前在 Chrome 中得到了支持，其目的是解决与 <code>preload</code> 相同的问题，但它存在一个问题：没有办法确定项目的优先级（<code>as</code> 当时还不存在），所以它们都是以相当低的优先级获取的。</p><p>非标准</p></li><li><p>有许多基于脚本的资源加载器，但它们无法控制浏览器的获取优先级队列，并面临着同样的性能问题。</p></li></ul><h2 id="nostate" tabindex="-1"><strong>NoState</strong> <a class="header-anchor" href="#nostate" aria-label="Permalink to &quot;**NoState**&quot;">​</a></h2><p>引入 NoState 预提取主要有以下两个动机：</p><p><strong>减少内存用量</strong></p><pre><code>- **NoState 预提取仅使用约 45MiB 的内存**。维护预加载扫描程序是 NoState 预提取的主要内存开销，在不同用例中，此开销保持相对稳定。增加提取大小或提取量对 NoState 预提取消耗的内存量不会产生显著影响。
- 相比之下，**预渲染通常消耗 100MiB 的内存，内存消耗上限为 150MiB**。这种高内存消耗使其不适合低端（即 RAM 小于 512MB）的设备。因此，Chrome 不会在低端设备上进行预渲染，而是[预连接](https://www.w3.org/TR/resource-hints/#dfn-preconnect)。
</code></pre><p><strong>为新的 Web 平台功能提供支持</strong></p><pre><code>- 通过预渲染，不应面向用户（例如播放音乐或视频）或执行有状态的操作（例如更改会话或本地存储空间）。不过，阻止在呈现网页时执行这些操作可能既困难又复杂。NoState 预提取只会提前提取资源，而不会执行代码或呈现网页。这样可以更轻松地防止发生面向用户的有状态操作。
</code></pre><h2 id="相关使用" tabindex="-1">相关使用 <a class="header-anchor" href="#相关使用" aria-label="Permalink to &quot;相关使用&quot;">​</a></h2><p>webpack的懒加载机制</p><p><s><strong>使用prefetch结合webpackChunkName组件打包名称，当浏览器空闲时加载资源，加载路由对应的组件时解析文件，并执行代码</strong></s></p><h2 id="性能指标" tabindex="-1">性能指标 <a class="header-anchor" href="#性能指标" aria-label="Permalink to &quot;性能指标&quot;">​</a></h2><blockquote><p>💡 <strong>读懂前端「性能优化」</strong><br><a href="https://tech.qimao.com/yi-wen-du-dong-qian-duan-xing-neng-you-hua/" target="_blank" rel="noopener noreferrer">https://tech.qimao.com/yi-wen-du-dong-qian-duan-xing-neng-you-hua/</a></p></blockquote><blockquote><p>💡 <strong>写给中高级前端关于性能优化的9大策略和6大指标</strong><br><a href="https://cloud.tencent.com/developer/article/2070655" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/2070655</a></p></blockquote><ul><li><p><strong>FP (First Paint) 首次绘制</strong></p><p>标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点。</p></li><li><p><strong>FCP (First Contentful Paint) 首次内容绘制</strong></p><p>标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素。</p><pre><code>  ![FCP.png](/notion/images/4acfdf22eb63b61bcfd8fb548d30f307.png)
</code></pre></li><li><p><strong>LCP (Largest Contentful Paint) 最大内容渲染</strong></p><p>衡量viewport内可见的最大内容元素的渲染时间。元素包括img、video、div及其他块级元素。</p><p>LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象.(2019年11月新增)。</p><p><img src="`+d+'" alt="LCP-1.png" loading="lazy"></p><p>根据google建议，为了给用户提供更好的产品体验，LCP应该低于2.5s。</p></li></ul><p><img src="'+k+'" alt="LCP-2.png" loading="lazy"></p><ul><li><p><strong>DCL (DomContentloaded)</strong></p><p>当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的完成加载。</p></li><li><p><strong>FMP(First Meaningful Paint) 首次有效绘制</strong></p><p>页面主角元素的首次有效绘制。例如，在 bilibili 上，主角元素就是视频元素；微博的博文是主要元素。</p></li><li><p><strong>L (onLoad)</strong></p><p>页面的onLoad时的时间点。当依赖的资源, 全部加载完毕之后才会触发。</p></li><li><p><strong>TTI (Time to Interactive) 可交互时间</strong></p><p>用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。</p></li><li><p><strong>TBT (Total Blocking Time) 页面阻塞总时长</strong></p><p>TBT汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总。</p><p>来个例子说明一下:</p></li></ul><p><img src="'+c+`" alt="TBT-1.png" loading="lazy"></p><pre><code>上图，有三个长任务，两个短任务。
</code></pre><p><img src="`+g+`" alt="TBT-2.png" loading="lazy"></p><pre><code>在主线程上运行任务所花费的总时间为560毫秒，但TBT只有345(200 + 40 + 105)毫秒的时间，被     视为阻塞时间(超过50ms的Task都会被记录).
</code></pre><ul><li><p><strong>FID (First Input Delay) 首次输入延迟</strong></p><p>FID (First Input Delay) 首次输入延迟: 指标衡量的是从用户首次与您的网站进行交互（即当他们单击链接，点击按钮等）到浏览器实际能够访问之间的时间, 下面来张图来解释FID和TTI的区别:</p></li></ul><p><img src="`+E+`" alt="FID-1.webp" loading="lazy"></p><pre><code>根据google建议，为了给用户提供更好的产品体验，FID应该低于100ms。
</code></pre><p><img src="`+u+'" alt="FID-2.png" loading="lazy"></p><ul><li><p><strong>CLS (Cumulative Layout Shift) 累积布局偏移</strong></p><p>CLS (Cumulative Layout Shift) 累积布局偏移: 总结起来就是一个元素初始时和其hidden之间的任何时间如果元素偏移了, 则会被计算进去, 具体的计算方法可看这篇文章 <a href="https://web.dev/cls/%5D" target="_blank" rel="noopener noreferrer">[https://web.dev/cls/]</a></p></li></ul><p><img src="'+b+'" alt="CLS.png" loading="lazy"></p><ul><li><p><strong>SI (Speed Index)</strong></p><p>SI (Speed Index): 指标用于显示页面可见部分的显示速度, 单位是时间,</p></li></ul><p>FP与FCP这两个指标之间的主要区别是：</p><ul><li>FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</li><li>FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。</li></ul><h3 id="network面板指标" tabindex="-1">Network面板指标： <a class="header-anchor" href="#network面板指标" aria-label="Permalink to &quot;Network面板指标：&quot;">​</a></h3><p><img src="'+y+`" alt="image.png" loading="lazy"></p><ul><li><strong>加入队列</strong>。浏览器会在连接开始之前以及在以下情况下将请求加入队列： <ul><li>还有优先级更高的请求。请求优先级由资源类型以及其在文档中的位置等因素决定。如需了解详情，请参阅 <code>fetchpriority</code> 指南的<a href="https://web.dev/articles/fetch-priority?hl=zh-cn#resource-priority" target="_blank" rel="noopener noreferrer">资源优先级部分</a>。</li><li>此来源已有 6 个 TCP 连接处于打开状态，这是上限。（仅适用于 HTTP/1.0 和 HTTP/1.1。）</li><li>浏览器正在磁盘缓存中暂时分配空间。</li></ul></li><li><strong>已暂停</strong>。连接开始后，请求可能会因<strong>队列</strong>中所述的任何原因而暂停。</li><li><strong>DNS 查询</strong>。浏览器正在解析请求的 IP 地址。</li><li><strong>初始连接</strong>。浏览器正在建立连接，包括 TCP 握手或重试以及协商 SSL。</li><li><strong>代理协商</strong>。浏览器正在与<a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener noreferrer">代理服务器</a>协商请求。</li><li><strong>已发送请求</strong>。正在发送请求。</li><li><strong>ServiceWorker 准备工作</strong>。浏览器正在启动服务工件。</li><li><strong>向 ServiceWorker 发出请求</strong>。请求正在发送到服务工件。</li><li><strong>等待中 (TTFB)</strong>。浏览器正在等待响应的第一个字节。TTFB 是“Time To First Byte”（收到第一个字节的时间）的缩写。此时间包括 1 次往返延迟时间和服务器准备响应所需的时间。</li><li><strong>内容下载</strong>。浏览器会直接从网络或 Service Worker 接收响应。此值是读取响应正文所花费的总时间。大于预期值可能表示网络速度缓慢，或者浏览器正忙于执行其他工作，导致延迟读取响应。</li></ul><h1 id="resource-scheduling-资源调度-优化记录笔记" tabindex="-1">Resource Scheduling（资源调度）优化记录笔记 <a class="header-anchor" href="#resource-scheduling-资源调度-优化记录笔记" aria-label="Permalink to &quot;Resource Scheduling（资源调度）优化记录笔记&quot;">​</a></h1><h2 id="一、问题背景" tabindex="-1">一、问题背景 <a class="header-anchor" href="#一、问题背景" aria-label="Permalink to &quot;一、问题背景&quot;">​</a></h2><p>在使用 <code>FormData.append(&#39;file&#39;, file)</code> 进行文件上传时（文件大小约 20KB），通过 Chrome DevTools → Network → Timing 面板观察到：</p><ul><li><strong>Resource Scheduling → Queueing 时间高达 1s ~ 1.7s</strong>；</li><li><code>Request sent / Waiting (TTFB) / Content Download</code> 均非常快；</li><li>后端接口耗时 &lt; 200ms；</li><li>前端无并发请求、无 loading 阻塞。</li></ul><p>结论：<strong>性能瓶颈不在网络或后端，而在浏览器资源调度阶段。</strong></p><hr><h2 id="二、resource-scheduling-是什么" tabindex="-1">二、Resource Scheduling 是什么 <a class="header-anchor" href="#二、resource-scheduling-是什么" aria-label="Permalink to &quot;二、Resource Scheduling 是什么&quot;">​</a></h2><p>Resource Scheduling（资源调度）发生在：</p><blockquote><p>JS 已调用 fetch / xhr，但浏览器尚未真正开始发送网络请求之前。</p></blockquote><p>该阶段由 Chrome Network Service 接管，用于：</p><ul><li>请求优先级评估</li><li>上传管道（Upload Pipeline）初始化</li><li>IO / 线程 / socket 资源分配</li><li>File 安全校验</li></ul><p>表现形式：</p><div class="language-plain vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JS fetch</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Request 入队（Queueing）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>满足调度条件后</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Connection Start</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><hr><h2 id="三、chrome-官方对-queueing-的解释-摘录" tabindex="-1">三、Chrome 官方对 Queueing 的解释（摘录） <a class="header-anchor" href="#三、chrome-官方对-queueing-的解释-摘录" aria-label="Permalink to &quot;三、Chrome 官方对 Queueing 的解释（摘录）&quot;">​</a></h2><p>请求在以下情况下会被加入队列：</p><ul><li>有更高优先级的请求存在</li><li>同一来源 TCP 连接数达到上限（HTTP/1.1 为 6）</li><li>浏览器正在为请求分配磁盘缓存空间</li><li>请求为 File / multipart 类型，需要额外准备工作</li></ul><p>📌 <strong>Queueing 不等于网络慢，也不等于 CPU 忙。</strong></p><hr><h2 id="四、现象与实验结论" tabindex="-1">四、现象与实验结论 <a class="header-anchor" href="#四、现象与实验结论" aria-label="Permalink to &quot;四、现象与实验结论&quot;">​</a></h2><h3 id="_1️⃣-只保留最小上传代码-无效果" tabindex="-1">1️⃣ 只保留最小上传代码（无效果） <a class="header-anchor" href="#_1️⃣-只保留最小上传代码-无效果" aria-label="Permalink to &quot;1️⃣ 只保留最小上传代码（无效果）&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> formData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FormData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;file&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rawFile);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> importWhitelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(formData);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>Queueing 仍然约 1s</li><li>排除 UI、并发请求、业务逻辑影响</li></ul><hr><h3 id="_2️⃣-同一文件多次上传" tabindex="-1">2️⃣ 同一文件多次上传 <a class="header-anchor" href="#_2️⃣-同一文件多次上传" aria-label="Permalink to &quot;2️⃣ 同一文件多次上传&quot;">​</a></h3><table tabindex="0"><thead><tr><th>次数</th><th>Queueing 时间</th></tr></thead><tbody><tr><td>第 1 次</td><td>~1000ms</td></tr><tr><td>第 2 次</td><td>&lt;100ms</td></tr></tbody></table><p>📌 结论：<strong>首次 File 上传存在一次性初始化成本</strong>。</p><hr><h3 id="_3️⃣-file-对象的本质" tabindex="-1">3️⃣ File 对象的本质 <a class="header-anchor" href="#_3️⃣-file-对象的本质" aria-label="Permalink to &quot;3️⃣ File 对象的本质&quot;">​</a></h3><ul><li><code>File</code> 继承自 <code>Blob</code></li><li>仅包含元数据（name / size / type / lastModified）</li><li>实际文件字节仍在磁盘</li><li>浏览器持有的是 <strong>安全句柄（handle）</strong></li></ul><p>上传时：</p><ol><li>在发送 HTTP 请求阶段才开始读取磁盘；</li><li>以流式（streaming）方式分块读取；</li><li>边读边发，不整体加载进内存；</li><li>不缓存文件内容。</li></ol><hr><h3 id="_4️⃣-关键对比实验-决定性证据" tabindex="-1">4️⃣ 关键对比实验（决定性证据） <a class="header-anchor" href="#_4️⃣-关键对比实验-决定性证据" aria-label="Permalink to &quot;4️⃣ 关键对比实验（决定性证据）&quot;">​</a></h3><h3 id="实验代码" tabindex="-1">实验代码 <a class="header-anchor" href="#实验代码" aria-label="Permalink to &quot;实验代码&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arrayBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> File</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([arrayBuffer], file.name, { type: file.type });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> formData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FormData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;file&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, f);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> importWhitelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(formData);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="实验结果" tabindex="-1">实验结果 <a class="header-anchor" href="#实验结果" aria-label="Permalink to &quot;实验结果&quot;">​</a></h3><p><img src="`+m+'" alt="image.png" loading="lazy"></p><ul><li>Resource Scheduling：<strong>1–2ms</strong></li><li>Queueing 几乎消失</li></ul><p>✅ 说明：</p><blockquote><p>真正耗时的是：Chrome 为“磁盘文件句柄”建立上传管道与安全校验，而不是网络发送本身。</p></blockquote><hr><h2 id="五、根本原因总结" tabindex="-1">五、根本原因总结 <a class="header-anchor" href="#五、根本原因总结" aria-label="Permalink to &quot;五、根本原因总结&quot;">​</a></h2><p>当 <code>FormData.append(&#39;file&#39;, file)</code> 且 <code>file</code> 来源于 <code>&lt;input type=&quot;file&quot;&gt;</code>：</p><p>Chrome 在 Resource Scheduling 阶段需要：</p><ol><li>初始化 Upload Pipeline（仅首次）</li><li>为磁盘 File 建立流式读取通道</li><li>分配 IO 线程 / backpressure 机制</li><li>执行文件来源与权限安全校验</li></ol><p>📌 这些工作：</p><ul><li>在 C++ 网络栈中完成</li><li>不占用 JS 主线程</li><li>不受文件大小影响</li><li>Performance 面板无法定位到具体帧</li></ul><hr><h2 id="六、已验证有效的优化手段" tabindex="-1">六、已验证有效的优化手段 <a class="header-anchor" href="#六、已验证有效的优化手段" aria-label="Permalink to &quot;六、已验证有效的优化手段&quot;">​</a></h2><h3 id="✅-方案-1-上传预热-推荐" tabindex="-1">✅ 方案 1：上传预热（推荐） <a class="header-anchor" href="#✅-方案-1-上传预热-推荐" aria-label="Permalink to &quot;✅ 方案 1：上传预热（推荐）&quot;">​</a></h3><ul><li>在弹窗打开或页面空闲时，发送一次“假上传”</li><li>提前触发 Upload Pipeline 初始化</li></ul><p>效果：</p><ul><li>首次 Queueing 从 ~1000ms → &lt;200ms</li></ul><hr><h3 id="✅-方案-2-文件选择即-append" tabindex="-1">✅ 方案 2：文件选择即 append <a class="header-anchor" href="#✅-方案-2-文件选择即-append" aria-label="Permalink to &quot;✅ 方案 2：文件选择即 append&quot;">​</a></h3><ul><li>在 <code>onChange</code> 时构建 <code>FormData</code></li><li>将 Queueing 前移到用户选文件阶段</li></ul><p>效果：</p><ul><li>点击“保存”时几乎无等待</li></ul><hr><h3 id="⚠️-方案-3-内存化文件-arraybuffer" tabindex="-1">⚠️ 方案 3：内存化文件（ArrayBuffer） <a class="header-anchor" href="#⚠️-方案-3-内存化文件-arraybuffer" aria-label="Permalink to &quot;⚠️ 方案 3：内存化文件（ArrayBuffer）&quot;">​</a></h3><ul><li>将 File 转为 ArrayBuffer 再重新构造 File</li><li>绕过磁盘文件句柄上传路径</li></ul><p>优点：</p><ul><li>Queueing ≈ 0</li></ul><p>代价：</p><ul><li>占用内存</li><li>不适合大文件</li></ul><hr><h2 id="七、结论性说明" tabindex="-1">七、结论性说明 <a class="header-anchor" href="#七、结论性说明" aria-label="Permalink to &quot;七、结论性说明&quot;">​</a></h2><blockquote><p>Resource Scheduling 阶段的耗时属于浏览器对文件上传的安全与资源调度机制，首次上传本地文件时需要初始化上传管道和校验文件句柄，因此会出现约 1 秒的排队时间。该行为与文件大小和接口性能无关，属于浏览器层面的正常设计。通过上传预热或提前构建 FormData，可显著降低用户感知延迟。</p></blockquote><hr><h2 id="八、最终结论" tabindex="-1">八、最终结论 <a class="header-anchor" href="#八、最终结论" aria-label="Permalink to &quot;八、最终结论&quot;">​</a></h2><ul><li>❌ 无法从根本“删除” Resource Scheduling</li><li>✅ 可以通过 <strong>提前触发 / 转移时机 / 绕过磁盘句柄</strong> 来优化体验</li><li>📌 当前现象符合 Chrome 内核预期行为，并非代码缺陷</li></ul>',161)]))}const S=i(f,[["render",F]]);export{_ as __pageData,S as default};
