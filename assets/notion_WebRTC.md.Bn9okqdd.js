import{_ as i,c as a,o as n,a2 as e}from"./chunks/framework.robbWsyO.js";const c=JSON.parse('{"title":"WebRTC中的RTCOfferOptions参数解释","description":"","frontmatter":{},"headers":[],"relativePath":"notion/WebRTC.md","filePath":"notion/WebRTC.md","lastUpdated":1753782063000}'),l={name:"notion/WebRTC.md"};function t(p,s,r,h,k,o){return n(),a("div",null,s[0]||(s[0]=[e(`<blockquote><p><strong>基于WebRTC、socket视频通话临界情况，甲方拨通，在乙方选择同意时挂断。</strong></p></blockquote><h1 id="webrtc中的rtcofferoptions参数解释" tabindex="-1">WebRTC中的RTCOfferOptions参数解释 <a class="header-anchor" href="#webrtc中的rtcofferoptions参数解释" aria-label="Permalink to &quot;WebRTC中的RTCOfferOptions参数解释&quot;">​</a></h1><p>您提供的文本是关于WebRTC API中<code>RTCOfferOptions</code>接口的参数说明。这些参数用于配置创建SDP offer时的行为。我来解释一下这些参数的含义：</p><h2 id="icerestart-参数" tabindex="-1">iceRestart 参数 <a class="header-anchor" href="#icerestart-参数" aria-label="Permalink to &quot;iceRestart 参数&quot;">​</a></h2><p>这个参数用于控制ICE (Interactive Connectivity Establishment) 连接的重启：</p><ul><li>当设置为<code>true</code>时，会生成新的ICE凭证，导致ICE过程重新启动</li><li>当设置为<code>false</code>(默认值)时，保持现有的ICE凭证，不重启ICE连接</li><li>ICE重启通常用于解决网络变化或连接问题的情况</li></ul><h2 id="offertoreceiveaudio-和-offertoreceivevideo-参数" tabindex="-1">offerToReceiveAudio 和 offerToReceiveVideo 参数 <a class="header-anchor" href="#offertoreceiveaudio-和-offertoreceivevideo-参数" aria-label="Permalink to &quot;offerToReceiveAudio 和 offerToReceiveVideo 参数&quot;">​</a></h2><p>这两个是遗留(Legacy)参数，用于控制是否接收音频和视频流：</p><ul><li>当设置为<code>true</code>时，即使本地不发送音频/视频，也会创建接收器来接收远程的音频/视频</li><li>当设置为<code>false</code>时，即使本地发送音频/视频，也不会接收远程的音频/视频</li><li>在现代WebRTC实现中，建议使用<code>RTCRtpTransceiver</code>来控制媒体流的收发方向</li></ul><h2 id="voiceactivitydetection-参数" tabindex="-1">voiceActivityDetection 参数 <a class="header-anchor" href="#voiceactivitydetection-参数" aria-label="Permalink to &quot;voiceActivityDetection 参数&quot;">​</a></h2><p>这个参数控制语音活动检测(VAD)功能：</p><ul><li>默认值为<code>true</code>，表示启用语音活动检测</li><li>启用后，当检测到&quot;静音&quot;或低音量时，会减少发送的音频数据，节省带宽</li><li>在某些场景下可能不适用，例如： <ul><li>音乐传输：可能会丢失重要的低音量声音</li><li>紧急通话：不应因为安静而切断音频</li></ul></li></ul><h2 id="什么意思" tabindex="-1">什么意思？ <a class="header-anchor" href="#什么意思" aria-label="Permalink to &quot;什么意思？&quot;">​</a></h2><p>语音活动检测(VAD)是一种技术，用于检测音频中是否有人在说话。当启用时(默认情况)，WebRTC会监测音频输入，只在检测到有声音时才传输数据，从而节省带宽。但在某些情况下，这可能导致问题，比如音乐传输时的低音量部分可能被错误地识别为&quot;静音&quot;而被过滤掉。</p><p>在WebRTC应用中，如果您需要传输音乐或其他非语音内容，或者是进行紧急通话，可能需要将<code>voiceActivityDetection</code>设置为<code>false</code>，以确保所有音频内容都被完整传输，不会因为音量低而被过滤。</p><p>这些参数通常在调用<code>RTCPeerConnection.createOffer()</code>方法时作为选项传入：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> offerOptions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  iceRestart: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  voiceActivityDetection: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createOffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(offerOptions)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">offer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理生成的offer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h1 id="rtcrtptransceiver-简介" tabindex="-1">RTCRtpTransceiver 简介 <a class="header-anchor" href="#rtcrtptransceiver-简介" aria-label="Permalink to &quot;RTCRtpTransceiver 简介&quot;">​</a></h1><p>RTCRtpTransceiver 是 WebRTC API 中的一个重要接口，它代表了一个双向的 RTP (实时传输协议) 媒体流通道。</p><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p>RTCRtpTransceiver 包含三个主要部分：</p><ol><li><strong>RTCRtpSender</strong>：负责发送媒体数据到远程对等方</li><li><strong>RTCRtpReceiver</strong>：负责从远程对等方接收媒体数据</li><li><strong>相关状态</strong>：影响发送器和接收器行为的共享状态</li></ol><h2 id="主要属性" tabindex="-1">主要属性 <a class="header-anchor" href="#主要属性" aria-label="Permalink to &quot;主要属性&quot;">​</a></h2><ul><li><strong>currentDirection</strong>：只读属性，表示收发器当前的传输方向（如&quot;sendrecv&quot;、&quot;sendonly&quot;、&quot;recvonly&quot;或&quot;inactive&quot;）</li><li><strong>direction</strong>：控制收发器的首选方向，可以设置来改变行为</li><li><strong>mid</strong>：在会话描述中唯一标识此收发器的媒体ID</li><li><strong>receiver</strong>：处理传入媒体的RTCRtpReceiver对象</li><li><strong>sender</strong>：处理传出媒体的RTCRtpSender对象</li><li><strong>stopped</strong>：布尔值，表示收发器是否已停止</li></ul><h2 id="主要方法" tabindex="-1">主要方法 <a class="header-anchor" href="#主要方法" aria-label="Permalink to &quot;主要方法&quot;">​</a></h2><ul><li><strong>setCodecPreferences()</strong>：设置收发器的首选编解码器</li><li><strong>stop()</strong>：永久停止收发器</li></ul><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><p>RTCRtpTransceiver 主要用于以下场景：</p><ol><li><strong>精确控制媒体流方向</strong>：可以设置为只发送、只接收、双向或不活动</li><li><strong>编解码器偏好设置</strong>：可以指定特定的编解码器优先级</li><li><strong>替代旧版选项</strong>：比如 offerToReceiveAudio 和 offerToReceiveVideo</li></ol><h2 id="使用示例" tabindex="-1">使用示例 <a class="header-anchor" href="#使用示例" aria-label="Permalink to &quot;使用示例&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取媒体设备</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, video: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RTCPeerConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将轨道从流添加到连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTracks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">track</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sender</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTrack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(track, stream);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 获取与此发送器关联的收发器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> transceivers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTransceivers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> transceiver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transceivers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t.sender </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sender);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 配置收发器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (track.kind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;video&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 视频设为只发送</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        transceiver.direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;sendonly&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (track.kind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;audio&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 音频保持双向</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        transceiver.direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;sendrecv&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建offer并设置本地描述</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createOffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">offer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setLocalDescription</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(offer));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>RTCRtpTransceiver 是现代 WebRTC 应用程序中控制媒体流的推荐方式，它提供了比旧版选项更精细的控制能力。</p><h1 id="rtcofferoptions-与-rtcrtptransceiver-的对比" tabindex="-1">RTCOfferOptions 与 RTCRtpTransceiver 的对比 <a class="header-anchor" href="#rtcofferoptions-与-rtcrtptransceiver-的对比" aria-label="Permalink to &quot;RTCOfferOptions 与 RTCRtpTransceiver 的对比&quot;">​</a></h1><p>RTCOfferOptions 和 RTCRtpTransceiver 是 WebRTC API 中两个不同的概念，它们在媒体流控制方面有不同的作用和应用场景。</p><h2 id="rtcofferoptions" tabindex="-1">RTCOfferOptions <a class="header-anchor" href="#rtcofferoptions" aria-label="Permalink to &quot;RTCOfferOptions&quot;">​</a></h2><p>RTCOfferOptions 是一个配置对象，用于在创建 SDP offer 时指定一些选项：</p><ol><li><strong>用途</strong>：配置 <code>createOffer()</code> 方法的行为</li><li><strong>主要属性</strong>： <ul><li><code>iceRestart</code>：控制是否重启 ICE 连接</li><li><code>offerToReceiveAudio</code>：(旧版)控制是否接收音频</li><li><code>offerToReceiveVideo</code>：(旧版)控制是否接收视频</li><li><code>voiceActivityDetection</code>：控制是否启用语音活动检测</li></ul></li><li><strong>使用方式</strong>：</li></ol><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> offerOptions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  iceRestart: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  offerToReceiveAudio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  offerToReceiveVideo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createOffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(offerOptions)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">offer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理offer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="rtcrtptransceiver" tabindex="-1">RTCRtpTransceiver <a class="header-anchor" href="#rtcrtptransceiver" aria-label="Permalink to &quot;RTCRtpTransceiver&quot;">​</a></h2><p>RTCRtpTransceiver 是一个对象，代表一个双向的媒体流通道：</p><ol><li><strong>用途</strong>：精确控制媒体流的发送和接收</li><li><strong>主要属性和方法</strong>： <ul><li><code>direction</code>：控制媒体流方向(sendrecv/sendonly/recvonly/inactive)</li><li><code>sender</code>：控制媒体发送</li><li><code>receiver</code>：控制媒体接收</li><li><code>setCodecPreferences()</code>：设置编解码器偏好</li><li><code>stop()</code>：停止收发器</li></ul></li><li><strong>使用方式</strong>：</li></ol><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> transceiver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTransceiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;video&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transceiver.direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;sendonly&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只发送不接收</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-label="Permalink to &quot;主要区别&quot;">​</a></h2><ol><li><strong>抽象层次</strong>： <ul><li>RTCOfferOptions 是配置参数，用于一次性设置</li><li>RTCRtpTransceiver 是对象实例，可以持续操作和修改</li></ul></li><li><strong>控制粒度</strong>： <ul><li>RTCOfferOptions 提供粗粒度控制(全局音频/视频开关)</li><li>RTCRtpTransceiver 提供细粒度控制(每个媒体轨道单独控制)</li></ul></li><li><strong>API 演进</strong>： <ul><li>RTCOfferOptions 中的 offerToReceiveAudio/Video 是旧版 API</li><li>RTCRtpTransceiver 是现代 WebRTC 推荐的 API</li></ul></li><li><strong>功能范围</strong>： <ul><li>RTCOfferOptions 仅影响 offer 创建</li><li>RTCRtpTransceiver 可以在连接的整个生命周期中调整</li></ul></li></ol><h2 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h2><p>在现代 WebRTC 应用中，推荐使用 RTCRtpTransceiver 来替代 RTCOfferOptions 中的旧版选项，因为它提供了更精确的控制和更丰富的功能。例如，要实现&quot;只接收音频不接收视频&quot;的功能：</p><p><strong>旧方式</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createOffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  offerToReceiveAudio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  offerToReceiveVideo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>新方式</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 音频收发器设为双向</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> audioTransceiver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTransceiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;audio&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">audioTransceiver.direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;sendrecv&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 视频收发器设为只发送</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> videoTransceiver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTransceiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;video&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">videoTransceiver.direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;sendonly&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>RTCRtpTransceiver 提供了更灵活、更强大的媒体流控制能力，是现代 WebRTC 应用的首选方案。</p>`,51)]))}const E=i(l,[["render",t]]);export{c as __pageData,E as default};
