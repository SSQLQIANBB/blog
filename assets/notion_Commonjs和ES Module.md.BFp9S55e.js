import{_ as i,c as n,o as a,a as e}from"./app.BLq0Lh-m.js";const o="/blog/assets/851f175c119ce0fa1dc36e01c833d5ae.B5hW5cbL.png",g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notion/Commonjs和ES Module.md","filePath":"notion/Commonjs和ES Module.md","lastUpdated":1756031832000}'),l={name:"notion/Commonjs和ES Module.md"};function t(r,s,p,d,h,c){return a(),n("div",null,s[0]||(s[0]=[e(`<blockquote><p>解析：Commonjs（广度优先-queue）和ES Module（深度优先-stack）</p></blockquote><p>对于 ESModule的工作流程主要包含以下三个步骤：</p><ul><li>构造(Construction) — 找到、下载并解析所有文件为模块记录。</li><li>实例化(Instantiation) — 在内存中找到位置用于存放所有的导出值，但是不用实际值来填充它们。然后让导出和导入都指向内存中的这些位置。这被称为链接（linking）。</li><li>评估(Evaluation) — 运行代码以真实值填充这些位置。</li></ul><p><strong>commonjs循环引用</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 11</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 22</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol><li><code>执行 node main.js -&gt; 第一行 require(a.js)</code>，（<code>node</code> 执行也可以理解为调用了require方法，我们省略<code>require(main.js)</code>内容）</li><li><code>进入 require(a)方法： 判断缓存（无） -&gt; 初始化一个 module -&gt; 将 module 加入缓存 -&gt; 执行模块 a.js 内容</code>，（需要注意 是<strong>先</strong>加入<strong>缓存</strong>， <strong>后执行</strong>模块内容）</li><li><code>a.js： 第一行导出 a = 1 -&gt; 第二行 require(b.js)</code>（a 只执行了第一行）</li><li><code>进入 require(b) 内 同 1 -&gt; 执行模块 b.js 内容</code></li><li><code>b.js： 第一行 b = 11 -&gt; 第二行 require(a.js)</code></li><li><code>require(a) 此时 a.js 是第二次调用 require -&gt; 判断缓存（有）-&gt; cachedModule.exports -&gt; 回到 b.js</code>（因为<code>js</code>对象引用问题 此时的 <code>cachedModule.exports = { a: 1 }</code>）</li><li><code>b.js：第三行 输出 { a: 1 } -&gt; 第四行 修改 b = 22 -&gt; 执行完毕回到 a.js</code></li><li><code>a.js：第二行 require 完毕 获取到 b -&gt; 第三行 输出 { b: 22 } -&gt; 第四行 导出 a = 2 -&gt; 执行完毕回到 main.js</code></li><li><code>main.js：获取 a -&gt; 第二行 输出 { a: 2 } -&gt; 执行完毕</code></li></ol><p><strong>es module 循环引用</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./foo&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bar } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bar } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li><strong>加载</strong> <strong><code>main.js</code></strong>： <ul><li><code>main.js</code> 导入了 <code>bar</code> 模块，所以首先会加载 <code>bar.js</code>。</li></ul></li><li><strong>加载</strong> <strong><code>bar.js</code></strong>： <ul><li><code>bar.js</code> 导入了 <code>foo</code> 模块，因此开始加载 <code>foo.js</code>。</li></ul></li><li><strong>加载</strong> <strong><code>foo.js</code></strong>： <ul><li><code>foo.js</code> 导入了 <code>bar</code> 模块。此时由于 <code>bar</code> 模块尚未完成加载，会返回一个未定义的占位符。</li><li><code>foo.js</code> 尝试访问并打印 <code>bar</code>，但是 <code>bar</code> 还没有完成初始化，这就会导致报错 <code>ReferenceError: Cannot access &#39;bar&#39; before initialization</code>。</li><li>在这一点，代码执行会被中断，报错信息会被抛出。</li></ul></li></ul><p><strong>未报错情况下执行顺序</strong>：</p><ol><li><strong>加载</strong> <strong><code>main.js</code></strong>： <ul><li><code>main.js</code> 导入了 <code>bar</code> 模块，所以首先会加载 <code>bar.js</code>。</li></ul></li><li><strong>加载</strong> <strong><code>bar.js</code></strong>： <ul><li><code>bar.js</code> 导入了 <code>foo</code> 模块，因此开始加载 <code>foo.js</code>。</li></ul></li><li><strong>加载</strong> <strong><code>foo.js</code></strong>： <ul><li><code>foo.js</code> 导入了 <code>bar</code> 模块。此时由于 <code>bar</code> 模块尚未完成加载，会返回一个未定义的占位符（因为 <code>bar</code> 模块还在初始化过程中）。</li><li><code>foo.js</code> 执行 <code>console.log(bar);</code> 打印出 <code>undefined</code>。这是因为 <code>bar</code> 还没有完成定义和导出。</li><li>然后 <code>foo.js</code> 导出 <code>foo</code> 变量并将其值设为 <code>&#39;foo&#39;</code>。</li></ul></li><li><strong>继续加载</strong> <strong><code>bar.js</code></strong>： <ul><li><code>bar.js</code> 继续执行，现在 <code>foo</code> 模块已经完成导出，<code>foo</code> 的值是 <code>&#39;foo&#39;</code>。</li><li><code>bar.js</code> 执行 <code>console.log(foo);</code> 打印出 <code>&#39;foo&#39;</code>。</li><li>然后 <code>bar.js</code> 导出 <code>bar</code> 变量并将其值设为 <code>&#39;bar&#39;</code>。</li></ul></li><li><strong>继续加载</strong> <strong><code>main.js</code></strong>： <ul><li><code>main.js</code> 继续执行，现在 <code>bar</code> 模块已经完成导出，<code>bar</code> 的值是 <code>&#39;bar&#39;</code>。</li><li><code>main.js</code> 执行 <code>console.log(bar);</code> 打印出 <code>&#39;bar&#39;</code>。</li></ul></li></ol><h3 id="输出结果总结" tabindex="-1">输出结果总结： <a class="header-anchor" href="#输出结果总结" aria-label="Permalink to &quot;输出结果总结：&quot;">​</a></h3><p>根据上述分析，输出结果将会是：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>esmodule执行顺序为先查找依赖，然后从最底层的子依赖开始执行，执行完再依次向上层父级代码继续执行； commonjs是动态执行，执行代码，遇到require进入依赖，再次执行依赖的代码，执行完跳到上层父级代码继续执行</p></blockquote><h2 id="commonjs-和-es6-module-的区别" tabindex="-1"><strong>CommonJs 和 ES6 Module 的区别</strong> <a class="header-anchor" href="#commonjs-和-es6-module-的区别" aria-label="Permalink to &quot;**CommonJs 和 ES6 Module 的区别**&quot;">​</a></h2><p>其实上面我们已经说到了一些区别</p><ul><li><code>CommonJs</code>导出的是变量的一份浅拷贝，<code>ES6 Module</code>导出的是变量的引用/绑定（<code>export default</code> 是特殊的）</li><li><code>CommonJs</code>是单个值导出，<code>ES6 Module</code>可以导出多个</li><li><code>CommonJs</code>是动态语法可以写在判断里，<code>ES6 Module</code>静态语法只能写在顶层</li><li><code>CommonJs</code>的 <code>this</code> 是当前模块，<code>ES6 Module</code>的 <code>this</code> 是 <code>undefined</code></li></ul><h3 id="思考" tabindex="-1">思考： <a class="header-anchor" href="#思考" aria-label="Permalink to &quot;思考：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印count结果</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印count结果</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p><code>exports</code> 只是 <code>module.exports</code> 的引用，一旦你给 <code>module.exports</code> 赋了一个新的对象或值，<code>exports</code> 就不再指向同一个对象</p></blockquote><p><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noreferrer">bookmark</a></p><h3 id="循环依赖问题" tabindex="-1"><strong>循环依赖问题</strong> <a class="header-anchor" href="#循环依赖问题" aria-label="Permalink to &quot;**循环依赖问题**&quot;">​</a></h3><p>在<strong>循环依赖（cyclic dependency）中，模块的依赖关系会形成一个图（graph）中的循环</strong>。通常，这个循环会很长，但为了更清楚地解释问题，我们用一个<strong>简单的短循环</strong>来举例说明。</p><hr><p><img src="`+o+'" alt="image.png" loading="lazy"></p><p><strong>左侧：</strong> 复杂的模块依赖图，包含一个由 4 个模块组成的循环。</p><p><strong>右侧：</strong> 一个简单的 2 模块循环。</p><h3 id="commonjs-模块的执行方式" tabindex="-1"><strong>CommonJS 模块的执行方式</strong> <a class="header-anchor" href="#commonjs-模块的执行方式" aria-label="Permalink to &quot;**CommonJS 模块的执行方式**&quot;">​</a></h3><p>让我们看看 CommonJS 模块在循环依赖中的工作方式。</p><ol><li><strong>主模块（main.js）开始执行，直到遇到</strong> <strong><code>require</code></strong> <strong>语句。</strong><ul><li>然后，它会去加载 <code>counter.js</code> 模块。</li></ul></li><li><strong>加载</strong> <strong><code>counter.js</code></strong> <strong>模块时，它尝试访问</strong> <strong><code>main.js</code></strong> <strong>的导出对象。</strong><ul><li>但此时，<code>main.js</code> 还未完成执行，因此 <code>counter.js</code> 访问 <code>message</code> 变量时会得到 <code>undefined</code>。</li><li>在 JS 引擎内部，它会在<strong>内存</strong>中为 <code>message</code> 变量分配空间，并将初始值设为 <code>undefined</code>。</li></ul></li></ol><hr><h3 id="内存状态示意" tabindex="-1"><strong>内存状态示意</strong> <a class="header-anchor" href="#内存状态示意" aria-label="Permalink to &quot;**内存状态示意**&quot;">​</a></h3><p>在 <code>counter.js</code> 运行时，它的 <code>require(&#39;./main&#39;)</code> 访问的是一个尚未完全初始化的 <code>main.js</code>，所以它只能获取 <code>undefined</code>，内存状态如下：</p><ul><li><strong><code>main.js</code></strong> <strong>还未执行完毕，因此</strong> <strong><code>message</code></strong> <strong>变量在</strong> <strong><code>counter.js</code></strong> <strong>里是</strong> <strong><code>undefined</code>****。</strong></li></ul><hr><ol><li><strong><code>counter.js</code></strong> <strong>继续执行到文件末尾，并设置一个定时器（<strong><strong><code>setTimeout</code></strong></strong>），希望稍后能获取</strong> <strong><code>message</code></strong> <strong>的正确值。</strong></li><li><strong>执行回到</strong> <strong><code>main.js</code>****，继续运行剩余代码。</strong></li><li><strong><code>message</code></strong> <strong>变量在</strong> <strong><code>main.js</code></strong> <strong>中被初始化，并存储到内存中。</strong><ul><li>但由于 <code>counter.js</code> 的 <code>require(&#39;./main&#39;)</code> 之前只获取到了 <code>undefined</code>，它的引用<strong>不会自动更新</strong>。</li></ul></li></ol><hr><h3 id="最终的问题" tabindex="-1"><strong>最终的问题</strong> <a class="header-anchor" href="#最终的问题" aria-label="Permalink to &quot;**最终的问题**&quot;">​</a></h3><p>尽管 <code>main.js</code> 已经正确地初始化了 <code>message</code>，但 <code>counter.js</code> <strong>仍然引用的是之前的</strong> <strong><code>undefined</code>****，而不会自动更新</strong>。</p><hr><h3 id="es-模块-esm-如何解决这个问题" tabindex="-1"><strong>ES 模块（ESM）如何解决这个问题？</strong> <a class="header-anchor" href="#es-模块-esm-如何解决这个问题" aria-label="Permalink to &quot;**ES 模块（ESM）如何解决这个问题？**&quot;">​</a></h3><p>如果**导出值（export）<strong>是通过</strong>“实时绑定”（live bindings）**的方式处理的，那么 <code>counter.js</code> 最终会看到正确的值。</p><ul><li>因为 ES 模块采用了<strong>三阶段解析机制</strong>： <ol><li><strong>构建（Construction Phase）</strong>：建立模块的导入/导出关系，但不执行代码。</li><li><strong>实例化（Instantiation Phase）</strong>：创建变量的引用，但不赋值。</li><li><strong>执行（Evaluation Phase）</strong>：真正执行代码，并更新变量的值。</li></ol></li></ul><p>这样，在<strong>模块执行完成后</strong>，<code>counter.js</code> 访问 <code>message</code> 变量时，就会获得<strong>最新的值</strong>，而不会停留在 <code>undefined</code>。</p><hr><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>CommonJS</strong> 采用的是<strong>值的拷贝（值传递）</strong>，所以在循环依赖的情况下，模块<strong>只能获取到当时的快照值</strong>，如果变量在稍后才赋值，<strong>导入模块不会看到更新后的值</strong>。</li><li><strong>ES 模块（ESM）</strong> 采用<strong>实时绑定（live bindings）</strong>，允许模块在执行完成后仍然能访问到最新的值，这使得<strong>循环依赖不会导致</strong> <strong><code>undefined</code></strong> <strong>问题</strong>。</li><li><strong>ES 模块的三阶段设计</strong> 让它能够支持复杂的循环依赖，这也是它的设计初衷之一。</li></ul>',48)]))}const u=i(l,[["render",t]]);export{g as __pageData,u as default};
